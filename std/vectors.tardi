
uses: std/_hashmaps
uses: std/_vectors
uses: std/math

exports:
    <vector> 2vector concat deep-push! each each2 empty? first fourth in?
    index-of? join last length map map2 nth pop! pop-left! push! push-left!
    reduce second set-nth! sort! subvector third sum frequencies ;

: 2vector           { } tuck push-left! tuck push-left! ;    /// a b -- xs

/// v -- x
: first    0 swap nth ;
/// v -- x
: second   1 swap nth ;
/// v -- x
: third    2 swap nth ;
/// v -- x
: fourth   3 swap nth ;

/// v -- x
: last     [ length 1 - ] keep nth ;

/// v -- ?
: empty?   length 0 == ;

// TODO: tardi (and others) often have lots of small, private, helper words.
// maybe we could facilitate that by having a way to make them private and
// scope them to only be visible inside a small set of other words, primarily
// one other word.

/// vector l -- l vector max index
: each-init-index-limit   swap dup length 0 ;

/// vector lambda -- lambda vector max index
: each-init-state   each-init-index-limit ;

/// max index -- max index ?
: each-more?   2dup > ;

/// vector m index -- item vector m index
: each-get-item   -rot [ [ nth ] 2keep ] dip rot ;

/// lambda item v m i -- lambda v m i
: each-clear-apply   [ swap [ apply ] keep ] 3dip ;

/// i -- i'
: each-next   1 + ;

/// lambda vector max index -- lambda vector max index'
: each-loop
    [ each-more? ] [
        each-get-item
        each-clear-apply
        each-next
    ] while ;

/// l v m i --
: each-cleanup   4drop ;

/// vector lambda --
: each   each-init-state each-loop each-cleanup ;

: find-min-length   [ length ] bi@ min ;                     /// xs ys -- n
: float-lists       -rot ;                                   /// q xs ys n -- q n xs ys
: nth-both          overd nth [ dupd nth ] dip ;             /// n xs ys -- n x y
: clean-apply       [ [ apply ] keep ] dip ;                 /// x y q n -- q n
: arrange-apply     [ nth-both 2swap clean-apply ] 2keep ;   /// q n xs ys -- q n xs ys

: each2-init        -rot 2dup find-min-length 0 swap ;       /// xs ys q -- q xs ys n l
: each2-continue?   2dup < ;                                 /// n l -- n l ?
: each2-apply       [ float-lists arrange-apply ] dip ;      /// q xs ys n l -- q n xs ys l
: each2-restack     rotd ;                                   /// q n xs ys l -- q xs ys n l
: each2-cleanup     5drop ;                                  /// q n xs ys l --

/// xs ys quot --
: each2
    each2-init
    [ each2-continue? ] [
        // q xs ys n l
        each2-apply
        each2-restack
        [ 1+ ] dip
    ] while
    each2-cleanup ;

/// vector lambda -- vector' lambda vector
: map-init   { } spin ;

/// vector' lambda item -- item lambda vector'
: map-init-step   spin ;

/// item lambda vector' -- item' lambda vector'
: map-clear-apply   [ [ apply ] keep ] dip ;

/// item l vector' -- vector' l
: map-push!   swap [ [ push! ] keep ] dip ;

/// vector' lambda vector -- vector' lambda
: map-loop
    [
        map-init-step
        map-clear-apply
        map-push!
    ] each ;

/// lambda --
: map-cleanup   drop ;

/// vector lambda -- vector'
: map   map-init map-loop map-cleanup ;

/// xs ys quot -- zs
: map2
    { } 2swap
    [
        reach apply
        over push!
    ] each2
    nip ;

/// vector init ( accum item -- accum ) -- accum
: reduce
    rot
    [ swap [ apply ] keep ] each 
    drop ;

/// xs -- s
: sum   0 [ + ] reduce ;

/// xs y x -- xs' y
: deep-push!   pick push! ;

/// copied from std/hashmaps to prevent an import loop
/// hm x --
: inc
    swap 2dup get
    [ 1+ ] [ drop 1 ] if
    swap set! ;

/// list -- hashmap
: frequencies
    <hashmap>
    [ dupd inc ] reduce ;

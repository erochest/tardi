
uses: std/_hashmaps
uses: std/_vectors
uses: std/math

exports:
    <vector> 1vector 2vector concat deep-push! each each2 empty? first first2 fourth in?
    index-of? join last length map map2 nth pop! pop-left! push! push-left!
    reduce second set-nth! sort! subvector third sum frequencies window-pairs 
    all? any? max filter partition [..] [..) [0..) in-bounds? remove-at lastn 
    split-at ;

: 1vector   { } [ push! ] keep ;       /// x -- {x}
: 2vector           { } tuck push-left! tuck push-left! ;    /// a b -- xs

/// v -- x
: first    0 swap nth ;
/// v -- x
: second   1 swap nth ;
/// v -- x
: third    2 swap nth ;
/// v -- x
: fourth   3 swap nth ;

: first2    [ first ] [ second ] bi ;   /// {xy} -- x y

/// v -- x
: last     [ length 1 - ] keep nth ;

/// v -- ?
: empty?   length 0 == ;

// TODO: tardi (and others) often have lots of small, private, helper words.
// maybe we could facilitate that by having a way to make them private and
// scope them to only be visible inside a small set of other words, primarily
// one other word.

/// vector l -- l vector max index
: each-init-index-limit   swap dup length 0 ;

/// vector lambda -- lambda vector max index
: each-init-state   each-init-index-limit ;

/// max index -- max index ?
: each-more?   2dup > ;

/// vector m index -- item vector m index
: each-get-item   -rot [ [ nth ] 2keep ] dip rot ;

/// lambda item v m i -- lambda v m i
: each-clear-apply   [ swap [ apply ] keep ] 3dip ;

/// i -- i'
: each-next   1 + ;

/// lambda vector max index -- lambda vector max index'
: each-loop
    [ each-more? ] [
        each-get-item
        each-clear-apply
        each-next
    ] while ;

/// l v m i --
: each-cleanup   4drop ;

/// vector lambda --
: each   each-init-state each-loop each-cleanup ;

: find-min-length   [ length ] bi@ min ;                     /// xs ys -- n
: float-lists       -rot ;                                   /// q xs ys n -- q n xs ys
: nth-both          overd nth [ dupd nth ] dip ;             /// n xs ys -- n x y
: clean-apply       [ [ apply ] keep ] dip ;                 /// x y q n -- q n
: arrange-apply     [ nth-both 2swap clean-apply ] 2keep ;   /// q n xs ys -- q n xs ys

: each2-init        -rot 2dup find-min-length 0 swap ;       /// xs ys q -- q xs ys n l
: each2-continue?   2dup < ;                                 /// n l -- n l ?
: each2-apply       [ float-lists arrange-apply ] dip ;      /// q xs ys n l -- q n xs ys l
: each2-restack     rotd ;                                   /// q n xs ys l -- q xs ys n l
: each2-cleanup     5drop ;                                  /// q n xs ys l --

/// xs ys quot --
: each2
    each2-init
    [ each2-continue? ] [
        // q xs ys n l
        each2-apply
        each2-restack
        [ 1+ ] dip
    ] while
    each2-cleanup ;

/// vector lambda -- vector' lambda vector
: map-init   { } spin ;

/// vector' lambda item -- item lambda vector'
: map-init-step   spin ;

/// item lambda vector' -- item' lambda vector'
: map-clear-apply   [ [ apply ] keep ] dip ;

/// item l vector' -- vector' l
: map-push!   swap [ [ push! ] keep ] dip ;

/// vector' lambda vector -- vector' lambda
: map-loop
    [
        map-init-step
        map-clear-apply
        map-push!
    ] each ;

/// lambda --
: map-cleanup   drop ;

/// vector lambda -- vector'
: map   map-init map-loop map-cleanup ;

/// xs ys quot -- zs
: map2
    { } 2swap
    [
        reach apply
        over push!
    ] each2
    nip ;

/// vector init ( accum item -- accum ) -- accum
: reduce
    rot
    [ swap [ apply ] keep ] each 
    drop ;

/// xs -- s
: sum   0 [ + ] reduce ;

/// xs y x -- xs' y
: deep-push!   pick push! ;

/// copied from std/hashmaps to prevent an import loop
/// hm x --
: inc
    swap 2dup get
    [ 1+ ] [ drop 1 ] if
    swap set! ;

/// list -- hashmap
: frequencies
    <hashmap>
    [ dupd inc ] reduce ;

: window/setup    #f { } rot ;           /// v -- ? accum v
: window/first?   swapd over #f? ;       /// prev accum x -- accum prev i ?
: window/store    nip swap ;             /// accum prev current -- current accum 
: window/pair     2vector over push! ;   /// accum prev current -- accum

/// vector -- vector/vector
: window-pairs
    window/setup
    [
        window/first? [
            window/store
        ] [
            [ window/pair ] keep
            swap
        ] if
    ] each
    nip ;

/// vector predicate -- ?
: all?
    swap #t
    [
        -rot
        [ [ apply ] keep ] dip
        rot and
    ] reduce
    nip ;

/// vector predicate -- ?
: any?
    swap #f
    [
        -rot
        [ [ apply ] keep ] dip
        rot or
    ] reduce
    nip ;

: filter?    [ pick apply ] keep swap ;      /// pred accum i -- pred accum i ?
: push-if!   [ over push! ] [ drop ] if ;    /// xs x ?       -- xs'
: (filter)   [ filter? push-if! ] reduce ;   /// p xs accum -- p accum
: filter     swap { } (filter) nip ;         /// xs p -- xs'

: partition/setup       swap { } { } 2vector ;              /// xs p -- p xs a
: partition/test        [ pick apply ] keep swap ;          /// p x i -- p x i ?
: partition/get-accum   [ second ] [ first ] if ;           /// a ? -- a'
: partition/clean       nip first2 ;                        /// p a -- ts fs
: partition/store       overd partition/get-accum push! ;   /// a i ? -- a'

/// p xs a -- p a'
: (partition)           [ partition/test partition/store ] reduce ;

/// xs p -- trues falses
: partition             partition/setup (partition) partition/clean ;

: more]?      2dup >= ;               /// a max current -- a max current ?
: store       [ pick push! ] keep ;   /// accum m current -- accum' m current

/// from to -- vector
: [..]
    { } spin
    [ more]? ] [ store 1+ ] while
    2drop ;

: more)?       2dup > ;                /// a max current -- a max current ?

/// from to -- vector
: [..)
    { } spin
    [ more)? ] [ store 1+ ] while
    2drop ;

: [0..)   0 swap [..) ;   /// n -- vector

: in-bounds?   2dup 0 rot length 1- check-bounds #f? ! ;   /// v i -- v i ?

: preslice   0 spin subvector ;                  /// v i -- v'
: postslice   swap [ length ] keep subvector ;   /// v i -- v'

/// vector i -- vector'
: remove-at
    in-bounds?
    [
        [ preslice ] [ 1+ postslice ] 2bi
        concat
    ] [ drop ] if ;

/// vector n -- vector to from
: indexes-from-end
    over length
    swap dupd - ;

: invalid-start-index   0 <= ;    /// i -- ?
: cleanup-indexes       2drop ;   /// to from --

: max   dup first [ math/max ] reduce ;   /// xs -- x

/// xs n -- xs'
: lastn
    indexes-from-end
    dup invalid-start-index [ cleanup-indexes ] [
        spin subvector
    ] if ;

: split-prefix   0 -rot subvector ;                      /// i xs -- pref
: split-post     [ length ] keep subvector ;             /// i xs -- post
: split-at       [ split-prefix ] [ split-post ] 2bi ;   /// i xs -- xs1 xs2
